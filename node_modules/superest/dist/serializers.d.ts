import { Field, FieldOptions, FieldValues, Lazy } from "./fields";
import { AbstractStorage, PK } from "./storage";
import { ExtractKeys } from "./utils";
export interface FieldsOptions<F extends Field = Field> extends Record<"both" | "response" | "request", Record<string, F>> {
}
export interface GettersOptions<Fields extends FieldsOptions> extends Record<string, (data: FieldsValues<Fields>["internal"]) => unknown> {
}
export declare type FieldsValues<Fields extends FieldsOptions> = {
    rawInternal: {
        [N in keyof (Fields["both"] & Fields["response"])]: FieldValues<(Fields["both"] & Fields["response"])[N]>["rawInternal"];
    };
    internal: {
        [N in keyof (Fields["both"] & Fields["response"])]: FieldValues<(Fields["both"] & Fields["response"])[N]>["internal"];
    };
    rawExternal: {
        [N in keyof (Fields["both"] & Fields["request"])]: FieldValues<(Fields["both"] & Fields["request"])[N]>["rawExternal"];
    };
    external: {
        [N in keyof (Fields["both"] & Fields["request"])]: FieldValues<(Fields["both"] & Fields["request"])[N]>["external"];
    };
};
export declare type Data<Fields extends FieldsOptions, Getters extends GettersOptions<Fields>> = FieldsValues<Fields>["internal"] & {
    [K in keyof Getters]: ReturnType<Getters[K]>;
};
export declare function build<Fields extends FieldsOptions<F>, PKField extends ExtractKeys<FieldsValues<Fields>["internal"], PropertyKey>, Getters extends GettersOptions<Fields>, F extends Field>(options: {
    fields: Fields;
    pkField: PKField;
    getters: Getters;
}): {
    new <Opts extends FieldOptions>(options: Opts): {
        toInternalValue(value: { [N in keyof (Fields["both"] & Fields["response"])]: FieldValues<(Fields["both"] & Fields["response"])[N]>["rawInternal"]; } | Extract<Data<Fields, Getters>[keyof Fields["both"] | keyof Fields["response"] | keyof Getters], string | number | symbol>): () => Data<Fields, Getters>;
        toExternalValue(value: { [N_1 in keyof (Fields["both"] & Fields["request"])]: FieldValues<(Fields["both"] & Fields["request"])[N_1]>["rawExternal"]; }): { [N_2 in keyof (Fields["both"] & Fields["request"])]: FieldValues<(Fields["both"] & Fields["request"])[N_2]>["external"]; };
        handleValidationError<T extends (...args: unknown[]) => unknown>(fn: T, data: unknown, key: string): (...args: Parameters<T>) => ReturnType<T>;
        validators: import("./validators").Validator[];
        readonly nullable: boolean | undefined;
        readonly optional: boolean | undefined;
        readonly options: Opts;
        toInternal(value: { [N in keyof (Fields["both"] & Fields["response"])]: FieldValues<(Fields["both"] & Fields["response"])[N]>["rawInternal"]; } | null): () => Opts["nullable"] extends true ? Data<Fields, Getters> | null : Data<Fields, Getters>;
        toExternal(value: { [N_1 in keyof (Fields["both"] & Fields["request"])]: FieldValues<(Fields["both"] & Fields["request"])[N_1]>["rawExternal"]; } | undefined): Opts["optional"] extends true ? { [N_2 in keyof (Fields["both"] & Fields["request"])]: FieldValues<(Fields["both"] & Fields["request"])[N_2]>["external"]; } | undefined : { [N_2 in keyof (Fields["both"] & Fields["request"])]: FieldValues<(Fields["both"] & Fields["request"])[N_2]>["external"]; };
        validate<T_1>(value: T_1): value is Exclude<T_1, null | undefined>;
        validateNull(value: unknown): value is null | undefined;
        runValidators(value: unknown): void;
    };
    readonly storage: AbstractStorage<Data<Fields, Getters>, Extract<Data<Fields, Getters>[keyof Fields["both"] | keyof Fields["response"] | keyof Getters], string | number | symbol>>;
    readonly pkField: PKField;
    readonly fields: Fields;
    readonly getters: Getters;
    getPK(value: { [N_3 in keyof (Fields["both"] & Fields["response"])]: FieldValues<(Fields["both"] & Fields["response"])[N_3]>["internal"]; } | Data<Fields, Getters> | Extract<Data<Fields, Getters>[keyof Fields["both"] | keyof Fields["response"] | keyof Getters], string | number | symbol>): Extract<Data<Fields, Getters>[keyof Fields["both"] | keyof Fields["response"] | keyof Getters], string | number | symbol>;
    matchFields<K extends string, V, R>(data: Record<K, V>, fields: Record<string, Field>, callback: (k: K, v: V, field: Field) => R): Record<K, R>;
    /**
     * Define descriptors because Vue 2.x will also define descriptors on the object
     * to observe changes, which will cover the raw data and make the `Proxy` get a wrong
     * value
     * @param data
     */
    commit(data: Lazy<{ [N_3 in keyof (Fields["both"] & Fields["response"])]: FieldValues<(Fields["both"] & Fields["response"])[N_3]>["internal"]; }>): Data<Fields, Getters>;
    /**
     * Define descriptors because Vue 2.x will also define descriptors on the object
     * to observe changes, which will cover the raw data and make the `Proxy` get a wrong
     * value
     * @param data
     */
    commit(data: Lazy<{ [N_3 in keyof (Fields["both"] & Fields["response"])]: FieldValues<(Fields["both"] & Fields["response"])[N_3]>["internal"]; }>[]): Data<Fields, Getters>[];
};
//# sourceMappingURL=serializers.d.ts.map