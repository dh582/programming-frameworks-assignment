"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListField = exports.DateField = exports.BooleanField = exports.NumberField = exports.StringField = exports.SimpleField = exports.Field = void 0;
const validators_1 = require("./validators");
class Field {
    // Strangely, if `options` is not made a attribute, the type `FieldValues` will fail
    constructor(options) {
        this.options = options;
        this.validators = [];
        this.nullable = options.nullable;
        this.optional = options.optional;
    }
    toInternal(value) {
        if (this.validateNull(value))
            return () => value;
        return this.toInternalValue(value);
    }
    toExternal(value) {
        if (value === undefined && this.optional)
            return value;
        this.validate(value);
        return this.toExternalValue(value);
    }
    /**
     * Entry method for validations.
     *
     * Skip main validations if the value is and is allowed to be `null`.
     * @param value
     * @returns Whether the validations are fully executed.
     */
    validate(value) {
        return !this.validateNull(value) && !void this.runValidators(value);
    }
    validateNull(value) {
        if (value == null)
            if (this.nullable)
                return true;
            else
                throw new validators_1.ValidationError(value, "Not nullable");
        else
            return false;
    }
    runValidators(value) {
        this.validators.forEach((v) => v.validate(value, this));
    }
}
exports.Field = Field;
class SimpleField extends Field {
    toInternalValue(value) {
        return () => value;
    }
    toExternalValue(value) {
        return value;
    }
}
exports.SimpleField = SimpleField;
class StringField extends SimpleField {
    constructor(options) {
        super(options);
        this.minLength = options.minLength;
        this.maxLength = options.maxLength;
        this.choices = options.choices;
        this.validators.push(new validators_1.TypeValidator("string"));
        if (options.choices)
            this.validators.push(new validators_1.ChoicesValidator(...options.choices));
        if (options.minLength || options.maxLength)
            this.validators.push(new validators_1.LengthValidator({
                max: options.maxLength,
                min: options.minLength,
            }));
    }
}
exports.StringField = StringField;
class NumberField extends SimpleField {
    constructor(options) {
        super(options);
        this.maxValue = options.maxValue;
        this.minValue = options.minValue;
        this.choices = options.choices;
        this.validators.push(new validators_1.TypeValidator("number"));
        if (options.choices)
            this.validators.push(new validators_1.ChoicesValidator(...options.choices));
        if (options.minValue || options.maxValue)
            this.validators.push(new validators_1.ValueRangeValidator({
                max: options.maxValue,
                min: options.minValue,
            }));
    }
}
exports.NumberField = NumberField;
class BooleanField extends SimpleField {
    constructor(options) {
        super(options);
        this.validators.push(new validators_1.TypeValidator("boolean"));
    }
}
exports.BooleanField = BooleanField;
class DateField extends Field {
    constructor(options) {
        var _a, _b;
        super(options);
        this.minValue = options.minValue;
        this.maxValue = options.maxValue;
        this.validators.push(new validators_1.IsInstanceValidator(Date));
        if (options.maxValue || options.minValue)
            this.validators.push(new validators_1.ValueRangeValidator({
                max: (_a = options.maxValue) === null || _a === void 0 ? void 0 : _a.getTime(),
                min: (_b = options.minValue) === null || _b === void 0 ? void 0 : _b.getTime(),
            }));
    }
    toInternalValue(value) {
        const ret = new Date(value);
        return () => ret;
    }
    toExternalValue(value) {
        return value.toISOString();
    }
}
exports.DateField = DateField;
class ListField extends Field {
    constructor(options) {
        super(options);
        this.field = options.field;
        this.validators.push(new validators_1.IsInstanceValidator(Array));
        this.validators.push({
            validate: (value) => {
                value.forEach((v) => this.field.validate(v));
            },
        });
    }
    toInternalValue(value) {
        const ret = value.map((v) => this.field.toInternal(v));
        return () => ret.map((v) => v());
    }
    toExternalValue(value) {
        return value.map((v) => this.field.toExternal(v));
    }
}
exports.ListField = ListField;
//# sourceMappingURL=fields.js.map