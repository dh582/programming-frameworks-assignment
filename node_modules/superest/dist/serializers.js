"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const fields_1 = require("./fields");
const storage_1 = require("./storage");
const validators_1 = require("./validators");
function build(options) {
    var _a;
    return _a = class Serializer extends fields_1.Field {
            constructor(options) {
                super(options);
                this.validators.push(new validators_1.IsInstanceValidator(Object));
                this.validators.push({
                    validate: (value) => {
                        Serializer.matchFields(value, {
                            ...Serializer.fields.both,
                            ...Serializer.fields.response,
                            ...Serializer.fields.request,
                        }, (k, v, field) => field.validate(v));
                    },
                });
            }
            static getPK(value) {
                return typeof value == "object"
                    ? value[Serializer.pkField]
                    : value;
            }
            static matchFields(data, fields, callback) {
                const entries = Object.entries(data)
                    .filter(([k]) => !!fields[k])
                    .map(([k, v]) => [k, callback(k, v, fields[k])]);
                return Object.fromEntries(entries);
            }
            static commit(data) {
                const toPreInternal = (data) => {
                    const fields = {
                        ...this.fields.both,
                        ...this.fields.response,
                        ...this.fields.request,
                    };
                    const processed = {};
                    for (const k in data) {
                        Object.defineProperty(processed, k, {
                            get: () => data[k](),
                            set: (v) => {
                                fields[k].validate(v);
                                data[k] = () => v;
                            },
                            configurable: true,
                            enumerable: true,
                        });
                    }
                    return processed;
                };
                const applyGetters = (data) => {
                    const getters = this.getters;
                    if (getters)
                        for (const k in getters) {
                            Object.defineProperty(data, k, {
                                get: () => getters[k](data),
                                configurable: true,
                                enumerable: true,
                            });
                        }
                    return data;
                };
                /**
                 * Ensure that the objects obtained through a specific primary key are always the same.
                 * @param data
                 */
                const save = (data) => {
                    const pk = this.getPK(data);
                    if (!this.storage.exists(pk))
                        return this.storage.insert(pk, data);
                    else {
                        if (this.getters)
                            // exclude getters
                            for (const k in data) {
                                if (k in this.getters)
                                    delete data[k];
                            }
                        return this.storage.update(pk, data);
                    }
                };
                if (data instanceof Array)
                    return data.map((data) => this.commit(data));
                const preInternal = toPreInternal(data);
                const internal = applyGetters(preInternal);
                return save(internal);
            }
            toInternalValue(value) {
                if (typeof value == "object") {
                    const data = Serializer.commit(Serializer.matchFields(value, {
                        ...Serializer.fields.both,
                        ...Serializer.fields.response,
                    }, (k, v, field) => this.handleValidationError(field.toInternal.bind(field), value, k)(v)));
                    return () => data;
                }
                else {
                    return () => Serializer.storage.retrieve(value);
                }
            }
            toExternalValue(value) {
                return Serializer.matchFields(value, {
                    ...Serializer.fields.both,
                    ...Serializer.fields.request,
                }, (k, v, field) => this.handleValidationError(field.toExternal.bind(field), value, k)(v));
            }
            handleValidationError(fn, data, key) {
                return (...args) => {
                    try {
                        return fn(...args);
                    }
                    catch (error) {
                        if (error instanceof validators_1.ValidationError) {
                            error.data = data;
                            error.path.unshift(key);
                        }
                        throw error;
                    }
                };
            }
        },
        _a.storage = new storage_1.Storage() // TODO: more detailed primary key generic type
    ,
        _a.pkField = options.pkField,
        _a.fields = options.fields,
        _a.getters = options.getters,
        _a;
}
exports.build = build;
//# sourceMappingURL=serializers.js.map