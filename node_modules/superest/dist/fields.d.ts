import { Validator } from "./validators";
export interface FieldOptions extends Record<string, unknown> {
    nullable?: boolean;
    optional?: boolean;
}
export declare type FieldValues<F extends Field> = F extends Field<infer Opts, infer VRI, infer VI, infer VRE, infer VE> ? {
    rawInternal: Opts["nullable"] extends true ? VRI | null : VRI;
    internal: Opts["nullable"] extends true ? VI | null : VI;
    rawExternal: Opts["optional"] extends true ? VRE | undefined : VRE;
    external: Opts["optional"] extends true ? VE | undefined : VE;
} : unknown;
export declare type Lazy<T> = {
    [P in keyof T]: () => T[P];
};
export declare type NonLazy<T> = T extends Lazy<infer R> ? R : unknown;
export declare abstract class Field<Opts extends FieldOptions = {}, VRI = unknown, VI = VRI, VRE = VI, VE = VRE> {
    readonly options: Opts;
    validators: Validator[];
    readonly nullable: boolean | undefined;
    readonly optional: boolean | undefined;
    constructor(options: Opts);
    abstract toInternalValue(value: VRI): () => VI;
    abstract toExternalValue(value: VRE): VE;
    toInternal(value: VRI | null): () => Opts["nullable"] extends true ? VI | null : VI;
    toExternal(value: VRE | undefined): Opts["optional"] extends true ? VE | undefined : VE;
    /**
     * Entry method for validations.
     *
     * Skip main validations if the value is and is allowed to be `null`.
     * @param value
     * @returns Whether the validations are fully executed.
     */
    validate<T>(value: T): value is Exclude<T, null | undefined>;
    validateNull(value: unknown): value is null | undefined;
    runValidators(value: unknown): void;
}
export declare abstract class SimpleField<Opts extends FieldOptions, V = unknown> extends Field<Opts, V> {
    toInternalValue(value: V): () => V;
    toExternalValue(value: V): V;
}
export declare class StringField<Opts extends FieldOptions, Choices extends string> extends SimpleField<Opts, Choices> {
    readonly minLength: number | undefined;
    readonly maxLength: number | undefined;
    readonly choices: Choices[] | undefined;
    constructor(options: Opts & {
        minLength?: number;
        maxLength?: number;
        choices?: Choices[];
    });
}
export declare class NumberField<Opts extends FieldOptions, Choices extends number> extends SimpleField<Opts, Choices> {
    readonly maxValue: number | undefined;
    readonly minValue: number | undefined;
    readonly choices: Choices[] | undefined;
    constructor(options: Opts & {
        maxValue?: number;
        minValue?: number;
        choices?: Choices[];
    });
}
export declare class BooleanField<Opts extends FieldOptions> extends SimpleField<Opts, boolean> {
    constructor(options: Opts);
}
export declare class DateField<Opts extends FieldOptions> extends Field<Opts, string, Date, Date, string> {
    readonly minValue: Date | undefined;
    readonly maxValue: Date | undefined;
    constructor(options: Opts & {
        minValue?: Date;
        maxValue?: Date;
    });
    toInternalValue(value: string): () => Date;
    toExternalValue(value: Date): string;
}
export declare class ListField<Opts extends FieldOptions, Child extends Field> extends Field<Opts, FieldValues<Child>["rawInternal"][], FieldValues<Child>["internal"][], FieldValues<Child>["rawExternal"][], FieldValues<Child>["external"][]> {
    readonly field: Child;
    constructor(options: Opts & {
        field: Child;
    });
    toInternalValue(value: FieldValues<Child>["rawInternal"][]): () => FieldValues<Child>["internal"][];
    toExternalValue(value: FieldValues<Child>["rawExternal"][]): FieldValues<Child>["external"][];
}
//# sourceMappingURL=fields.d.ts.map